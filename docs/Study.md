### ✏️ 의존성 주입
`Dependency Injection(DI)`란, 객체(ex: 클라이언트)가 필요로 하는 것을 외부에서 전달해 주는 것을 말한다.  
스프링 어노테이션을 사용하면 클래스간의 의존관계를 스프링 컨테이너가 자동으로 연결해준다.
- 주입자 : 서비스를 생성해서 클라이언트에 주입
- 인터페이스 : 클라이언트와 서비스가 어떻게 상호작용할지 정의하는 클래스
#### 왜 사용하는가?
- 객체들 간의 `상호작용을 최소화`하기 위해 -> 한 클래스를 수정했을 때 다른 클래스를 수정해야 하는 상황을 방지해준다.
ex) 쇼핑몰에서 물건을 구매할 때 소비자는 어떤 방식으로 옷이 생산되고 배달되는지는 모르지만, 집 앞에 제대로 배송만 되면 ok.
- 코드의 재사용성, 유연성이 높아진다.
#### @Autowired?
- IoC 컨테이너에 빈으로 등록이 된 객체에 `의존성을 주입`한다.
- 의존성 주입 방법
  - 생성자에 @Autowired 붙이기 (👍)
  - 필드에 @Autowired 붙이기
  - setter 메소드에 @Autowired 붙이기
#### 참고 링크
[의존성 주입의 개념과 방법](https://velog.io/@sana/DI-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85Dependency-Injection-%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EB%B0%A9%EB%B2%95)  
[의존성 주입 3가지 방법 - (생성자 주입, Field 주입, Setter 주입)](https://dev-coco.tistory.com/70)
___
### ✏️ JPQL
- 엔티티 객체를 대상으로 쿼리 수행. -> 객체 지향 쿼리
- 특정 데이터베이스 SQL에 의존하지 않음.
- JPA에서 제공하는 `@Query` 어노테이션 이용
#### @Param?
파라미터 변수를 JPQL에 전달한다.  
**단점**  
잘못 입력하면 컴파일 시점에 에러를 발견할 수 없음.  
-> 보완 방법: `Querydsl`
#### Querydsl?
JPQL을 코드로 작성할 수 있도록 도와주는 빌더 API
pom.xml 파일의 <dependencies> 사이에 의존성 추가해야 사용 가능.
- SQL문을 문자열이 아닌 코드로 작성하기 때문에 컴파일러가 체크 가능
- 고정되지 않고 동적으로 쿼리 생성 가능
#### JPAQueryFactory
Querydsl이 제공하는 JPA를 사용하여 데이터를 조회할 때 사용하는 클래스
#### JAPQuery 데이터 반환 메소드
- List<T> fetch : 조회 결과 리스트 반환
- T fetchFirst() : 조회 대상 중 1건만 반환
___
### ✏️ 영속성 컨텍스트
- 엔티티를 `영구 저장`하는 환경이라는 뜻.  
- 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 `가상의 데이터베이스` 같은 역할을 한다. 
- `엔티티 매니저`를 통해 접근 가능하다.
#### 엔티티 매니저
엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저가 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

#### 참고 링크
[영속성 컨텍스트란?](https://velog.io/@neptunes032/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80)